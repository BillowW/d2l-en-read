

<!--
 * @version:
 * @Author:  StevenJokes https://github.com/StevenJokes
 * @Date: 2020-07-13 17:06:51
 * @LastEditors:  StevenJokes https://github.com/StevenJokes
 * @LastEditTime: 2020-07-13 17:10:45
 * @Description:
 * @TODO::
 * @Reference:
-->

# 编译器和解释器

到目前为止，这本书主要关注命令式编程，它使用了诸如 print，+ 或者 if 这样的语句来改变程序的状态。考虑以下简单命令式程序的示例。

TODO:CODE

Python是一个解释性语言。在计算 fancy _ func 时，它按顺序执行构成函数主体的操作。也就是说，它将计算 e = add (a，b) ，并将结果存储为变量 e，从而改变程序的状态。接下来的两个语句 f = add (c，d)和 g = add (e，f)将以类似的方式执行添加操作，并将结果作为变量存储。图12.1.1显示了数据流。

虽然命令式编程是方便的，但是它可能是低效的。一方面，即使在 fancy _ func 中反复调用 add 函数，Python 也会分别执行这三个函数调用。如果在一个 GPU 上(甚至在多个 GPU 上)执行这些命令，Python 解释器所产生的开销就会变得非常大。此外，它需要保存 e 和 f 的变量值，直到 fancy _ func 中的所有语句都被执行。这是因为我们不知道在执行语句 e = add (a，b)和 f = add (c，d)之后，程序的其他部分是否会使用变量 e 和 f。

## 符号编程

虑另一种方法，即符号编程，其中计算通常只在完全定义了进程之后才执行。这个策略被多个深度学习框架使用，包括 Theano、 Keras 和 TensorFlow (后两个框架已经获得了命令式扩展)。它通常包括以下步骤:

    1. 定义要执行的操作。
    2. 将操作编译成可执行程序。
    3. 提供所需的输入并调用已编译的程序执行。

这允许进行大量的优化。首先，在许多情况下，我们可以跳过 Python 解释器，从而消除一个性能瓶颈，这个瓶颈可能在 CPU 上的一个 Python 线程配对的多个快速 gpu 上变得非常重要。其次，编译器可能会优化并重写上面的代码到 print ((1 + 2) + (3 + 4)) ，甚至 print (10)。这是可能的，因为编译器在将代码转换成机器指令之前可以看到完整的代码。例如，只要不再需要某个变量，它就可以释放内存(或者永远不分配内存)。或者，它可以将代码完全转换为等价的片段。为了得到一个更好的想法，可以考虑下面的命令式编程模拟(毕竟它是 Python)。

TODO:CODE

命令式（解释性）编程和符号式编程之间的区别如下：

* 命令式编程更容易。 当在Python中使用命令式编程时，大多数代码都简单明了且易于编写。 调试命令性编程代码也更加容易。 这是因为更容易获得和打印所有相关的中间变量值，或使用Python的内置调试工具。
* 符号编程更有效且更容易移植。 它使得在编译过程中优化代码变得更加容易，同时还具有将程序移植为独立于Python的格式的能力。 这允许程序在非Python环境中运行，从而避免了与Python解释器有关的任何潜在性能问题。
